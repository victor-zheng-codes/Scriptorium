import { exec as execCallback } from "child_process";
import util from "util";

const allowedLanguages = ["python", "javascript", "java", "c", "cpp"];
const TIMEOUT = 10000; // 10 seconds

// Code to promisify exec generated by ChatGPT
const exec = util.promisify(execCallback);

let isRunning = false; // Used to prevent running two programs at once

export default async function handler(req, res) {
    if (req.method !== "POST") {
        res.setHeader('Allow', ['POST']);
        return res.status(405).json({ success: false, error: `Method ${req.method} not allowed` });
    }

    if (isRunning) {
        return res.status(429).json({ success: false, error: `Another program is currently being executed, please try again later.` });
        // Error 429 (too many requests)
    }

    let { code, language, input = "" } = req.body;
    if (typeof code !== "string" || typeof language !== "string" || typeof input !== "string") {
        return res.status(400).json({ success: false, error: "code, language, and input must be strings" });
    } else if (!allowedLanguages.includes(language.toLowerCase())) {
        return res.status(400).json({ success: false, error: "Invalid language. Accepted languages: python, javascript, java, c, cpp" });
    }

    if (!input.endsWith("\n")) {
        input = input + "\n"; // Add newline to the end of standard input if no newline present
    }

    let runCommand = null, compileCommand = null;
    code = code.replace(/"/g, '\\"'); // Escape double quotes to prevent syntax errors when running
    input = input.replace(/"/g, '\\"');

    // Switch statement and execution logic generated by ChatGPT, with some modification
    switch (language.toLowerCase()) {
        case "python":
            runCommand = `printf "${input}" | python3 -c "${code}"`;
            break;

        case "javascript":
            code = code.replace(/`/g, '\\`').replace(/\$/g, '\\$');
            runCommand = `printf "${input}" | node -e "${code}"`;
            break;

        case "java":
            const classNameMatch = code.match(/public\s+class\s+(\w+)/); // Get first public class name
            const className = classNameMatch ? classNameMatch[1] : 'TempClass';

            const javaFilePath = `tmp/${className}.java`;
            compileCommand = `printf "%s\n" "${code}" > ${javaFilePath} && javac ${javaFilePath}`;
            runCommand = `printf "${input}" | java -cp tmp ${className}`;
            break;

        case "c":
            const cFilePath = `tmp/temp.c`;
            const cExecutablePath = `tmp/ctemp`;

            compileCommand = `printf "%s\n" "${code}" > ${cFilePath} && gcc -Wall ${cFilePath} -o ${cExecutablePath}`;
            runCommand = `printf "${input}" | ${cExecutablePath}`;
            break;
            
        case "cpp":
            const cppFilePath = `tmp/temp.cpp`;
            const cppExecutablePath = `tmp/cpptemp`;

            compileCommand = `printf "%s\n" "${code}" > ${cppFilePath} && g++ -Wall ${cppFilePath} -o ${cppExecutablePath}`;
            runCommand = `printf "${input}" | ${cppExecutablePath}`;
            break;
    }

    isRunning = true;

    // Compilation and execution code generated by ChatGPT, with some modification
    let output = "";
    let warnings = "";
    try {
        if (compileCommand) { // Run compilation if compileCommand exists
            try {
                const { stdout: compileStdout, stderr: compileStderr } = await exec(compileCommand, { timeout: TIMEOUT });

                // Compilation succeeded
                output += compileStdout + "\n";
                if (compileStderr) { // Warnings present
                    warnings = compileStderr;
                }
            } catch (compileError) {
                // If compilation fails, handle it here
                isRunning = false;
                return res.status(400).json({
                    success: false,
                    error: compileError.stderr || "",
                    output: compileError.stdout || "",
                    warnings
                });
            }
        }

        // Run execute command only if compilation succeeded
        const { stdout: runStdout, stderr: runStderr } = await exec(runCommand, { timeout: TIMEOUT });
        output += runStdout;
        isRunning = false;

        return res.status(200).json({ success: true, output, error: runStderr, warnings });
    } catch (error) {
        isRunning = false;

        const isTimeout = error.signal === "SIGTERM";

        return res.status(400).json({
            success: false,
            error: isTimeout ? "Execution timed out (10 second limit)" : error.stderr || "Runtime error occurred.",
            output: error.stdout || "",
            warnings
        });
    }
}
