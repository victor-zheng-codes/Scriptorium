import { exec as execCallback } from "child_process";
import util from "util";

const allowedLanguages = ["python", "javascript", "java", "c", "cpp"];
const TIMEOUT = 10000; // 10 seconds

// Code to promisify exec generated by ChatGPT
const exec = util.promisify(execCallback);

export default async function handler(req, res) {
    if (req.method !== "POST") {
        res.setHeader('Allow', ['POST']);
        return res.status(405).json({ success: false, error: `Method ${req.method} not allowed` });
    }

    let { code, language, input = "" } = req.body;
    if (typeof code !== "string" || typeof language !== "string" || typeof input !== "string") {
        return res.status(400).json({ success: false, error: "code, language, and input must be strings" });
    } else if (!allowedLanguages.includes(language.toLowerCase())) {
        return res.status(400).json({ success: false, error: "Invalid language. Accepted languages: python, javascript, java, c, cpp" });
    }

    if (!input.endsWith("\n")) {
        input = input + "\n"; // Add newline to the end of standard input if no newline present
    }

    let runCommand = null, compileCommand = null;
    code = code.replace(/"/g, '\\"'); // Escape double quotes to prevent syntax errors when running
    input = input.replace(/"/g, '\\"');
    code = code.replace(/`/g, '\\`').replace(/\$/g, '\\$');

    const codeFilePath = `tmp/`;

    // Switch statement and execution logic generated by ChatGPT, with some modification
    switch (language.toLowerCase()) {
        case "python":
            const pythonFilePath = "main.py";
            codeFilePath += pythonFilePath;

            // runCommand = `python3 -c "${code}"`;
            break;

        case "javascript":
            const jsFilePath = "main.js";
            codeFilePath += jsFilePath;

            //runCommand = `node -e "${code}"`;
            break;

        case "java":
            const javaFilePath = "Main.java";
            //const className = "Main"
            codeFilePath += javaFilePath;

            // compileCommand = `javac ${javaFilePath}`;
            // runCommand = `java -cp tmp ${className}`;
            break;

        case "c":
            const cFilePath = `main.c`;
            // const cExecutablePath = `tmp/ctemp`;

            codeFilePath += cFilePath;

            // compileCommand = `printf "%s\n" "${code}" > ${cFilePath} && gcc -Wall ${cFilePath} -o ${cExecutablePath}`;
            // runCommand = `${cExecutablePath}`;
            break;
            
        case "cpp":
            const cppFilePath = `main.cpp`;
            //const cppExecutablePath = `tmp/cpptemp`;

            codeFilePath += cppFilePath;

            // compileCommand = `printf "%s\n" "${code}" > ${cppFilePath} && g++ -Wall ${cppFilePath} -o ${cppExecutablePath}`;
            // runCommand = `${cppExecutablePath}`;
            break;

        case "go":
            const goFilePath = `main.go`;

            codeFilePath += goFilePath;

        case "csharp":
            const csharpFilePath = `main.cs`;
            codeFilePath += csharpFilePath;

        case "perl":
            const perlFilePath = `main.pl`;

            codeFilePath += perlFilePath;


        case "php":
            const phpFilePath = `main.php`;

            codeFilePath += phpFilePath;


        case "ruby":
            const rubyFilePath = `main.rb`;

            codeFilePath += rubyFilePath;


        case "rust":
    }
    const inputFilePath = "tmp/input.txt";
    const writeCodeCommand = `printf "%s\n" "${code}" > ${codeFilePath}`; // Write code to file
    const writeInputCommand = `printf "%s\n" "${input}" > ${inputFilePath}`; // Write standard input to file for redirection

    try {
        // Write code and standard input to corresponding files
        await exec(`${writeCodeCommand} && ${writeInputCommand}`, { timeout: TIMEOUT });
    } catch (error) {
        const isTimeout = error.signal === "SIGTERM";

        return res.status(400).json({
            success: false,
            error: isTimeout ? "Execution timed out (10 second limit)" : error.stderr || "Runtime error occurred.",
            // output: error.stdout || "",
            // warnings
        });
    }

    const dockerImages = {
        python: "python:3.10",
        node: "node:20",
        java: "openjdk:20",
        cpp: "gcc:12",
        csharp: "mcr.microsoft.com/dotnet/sdk:8.0",
    };

    const image = dockerImages[language];
    if (!image) return callback("Unsupported language");

    const command = `docker run --rm -v ${codeFilePath}:/app -w /app ${image} <run-command>`;
    exec(command, (error, stdout, stderr) => {
        if (error) {
        return callback(stderr || "Execution error");
        }
        callback(null, stdout);
    });

    // Compilation and execution code generated by ChatGPT, with some modification
    // let output = "";
    // let warnings = "";
    // try {
    //     if (compileCommand) { // Run compilation if compileCommand exists
    //         try {
    //             const { stdout: compileStdout, stderr: compileStderr } = await exec(compileCommand, { timeout: TIMEOUT });

    //             // Compilation succeeded
    //             output += compileStdout + "\n";
    //             if (compileStderr) { // Warnings present
    //                 warnings = compileStderr;
    //             }
    //         } catch (compileError) {
    //             // If compilation fails, handle it here
    //             return res.status(400).json({
    //                 success: false,
    //                 error: compileError.stderr || "",
    //                 output: compileError.stdout || "",
    //                 warnings
    //             });
    //         }
    //     }

    //     // Run execute command only if compilation succeeded
    //     const { stdout: runStdout, stderr: runStderr } = await exec(runCommand, { timeout: TIMEOUT });
    //     output += runStdout;

    //     return res.status(200).json({ success: true, output, error: runStderr, warnings });
    // } catch (error) {

    //     const isTimeout = error.signal === "SIGTERM";

    //     return res.status(400).json({
    //         success: false,
    //         error: isTimeout ? "Execution timed out (10 second limit)" : error.stderr || "Runtime error occurred.",
    //         output: error.stdout || "",
    //         warnings
    //     });
    // }
}
