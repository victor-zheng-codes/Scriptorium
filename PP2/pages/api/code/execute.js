import { exec as execCallback } from "child_process";
import util from "util";

// const allowedLanguages = ["python", "javascript", "java", "c", "cpp"];
const TIMEOUT = 10000; // 10 seconds

// Code to promisify exec generated by ChatGPT
const exec = util.promisify(execCallback);

export default async function handler(req, res) {
    if (req.method !== "POST") {
        res.setHeader('Allow', ['POST']);
        return res.status(405).json({ success: false, error: `Method ${req.method} not allowed`, output: ""  });
    }
    // check pre requisites before executing
    let { code, language, input = "" } = req.body;
    if (!language ) {
        return res.status(404).json({ success: false, error: "Missing language required param", output: "" });
    }
    else if (!code ) {
        return res.status(404).json({ success: false, error: "Missing code required param", output: ""  });
    }
    else if (typeof code !== "string" || typeof language !== "string" || typeof input !== "string") {
        return res.status(400).json({ success: false, error: "code, language, and input must be strings", output: ""  });
    }

    // we do this below now
    // } else if (!allowedLanguages.includes(language.toLowerCase())) {
    //     return res.status(400).json({ success: false, error: "Invalid language. Accepted languages: python, javascript, java, c, cpp", output: ""   });
    // }

    const dockerImages = {
        python: "python:3.10",
        javascript: "node:20",
        java: "openjdk:20",
        cpp: "gcc:12",
        c: "gcc:12",
        ruby: "ruby:3.3",
        php: "php:8.2-cli",
        perl: "perl:5.36",
        csharp: "mcr.microsoft.com/dotnet/sdk:8.0",
        go: "golang:1.21",
        rust:"rust:1.73",
    };

    const image = dockerImages[language];
    if (!image) return res.status(404).json({
            success: false,
            error: "Unsupported language",
            output: "",
    });


    if (!input.endsWith("\n")) {
        input = input + "\n"; // Add newline to the end of standard input if no newline present
    }

    let runCommand = null, compileCommand = null;
    code = code.replace(/"/g, '\\"'); // Escape double quotes to prevent syntax errors when running
    input = input.replace(/"/g, '\\"');
    code = code.replace(/`/g, '\\`').replace(/\$/g, '\\$');

    let codeFilePath = `tmp/`;
    
    // instructions for running
    // let instructions = '';

    // Switch statement and execution logic generated by ChatGPT, with some modification
    switch (language.toLowerCase()) {
        case "python":
            const pythonFilePath = "main.py";
            codeFilePath += pythonFilePath;

            runCommand = `python ${pythonFilePath}`;
            break;

        case "javascript":
            const jsFilePath = "main.js";
            codeFilePath += jsFilePath;

            runCommand = `node "${jsFilePath}"`;
            break;

        case "java":
            const javaFilePath = "Main.java";
            //const className = "Main"
            codeFilePath += javaFilePath;

            // compileCommand = `javac ${javaFilePath}`;
            runCommand = `bash -c "javac Main.java && java Main"`
            break;

        case "c" || "C":
            const cFilePath = `main.c`;
            // const cExecutablePath = `tmp/ctemp`;

            codeFilePath += cFilePath;

            // runCommand = `printf "%s\n" "${code}" > main.c && gcc -Wall main.c -o main.c`;
            runCommand = `bash -c "gcc -Wall main.c -o main && ./main"`;
            break;
            
        case "cpp":
            const cppFilePath = `main.cpp`;
            //const cppExecutablePath = `tmp/cpptemp`;

            codeFilePath += cppFilePath;

            // compileCommand = `printf "%s\n" "${code}" > ${cppFilePath} && g++ -Wall ${cppFilePath} -o ${cppExecutablePath}`;
            runCommand = `bash -c "g++ -Wall main.cpp -o main && ./main"`;
            break;

        case "go":
            const goFilePath = `main.go`;

            codeFilePath += goFilePath;

        case "csharp":
            const csharpFilePath = `main.cs`;
            codeFilePath += csharpFilePath;

        case "perl":
            const perlFilePath = `main.pl`;

            codeFilePath += perlFilePath;


        case "php":
            const phpFilePath = `main.php`;

            codeFilePath += phpFilePath;


        case "ruby":
            const rubyFilePath = `main.rb`;

            codeFilePath += rubyFilePath;

        case "rust":
            const rustFilePath = `main.rb`;

            codeFilePath += rustFilePath;
        default: 
            console.log("ERROR, language not found")
    }
    const inputFilePath = "tmp/input.txt";
    const writeCodeCommand = `printf "%s\n" "${code}" > ${codeFilePath}`; // Write code to file
    const writeInputCommand = `printf "%s\n" "${input}" > ${inputFilePath}`; // Write standard input to file for redirection

    try {
        // Write code and standard input to corresponding files
        const { stdout, stderr} = await exec(`${writeCodeCommand} && ${writeInputCommand}`, { timeout: TIMEOUT });
    } catch (error) {
        const isTimeout = error.signal === "SIGTERM";

        return res.status(400).json({
            success: false,
            error: isTimeout ? "Execution timed out (10 second limit)" : error.stderr || "Compilation or runtime error occurred.",
            output: error.stdout || "",
            // warnings
        });
    }

    // codeFilePath = codeFilePath.replace(/^tmp\//, "");

    // current directory
    // const command = `docker run --rm -v ${process.cwd()}/tmp:/app -w /app ${imageLanguage} ${instructions}`;
    const command = `docker run --rm -v ${process.cwd()}/tmp:/app -w /app ${image} ${runCommand}`;

    console.log("running: " + command)
    
    try {
        const { stdout, stderr } = await exec(command);

        console.log({
            success: true,
            error: stderr,
            output: stdout
        })

        return res.status(201).json({
            success: true,
            error: stderr,
            output: stdout,
        });
    } catch (error) {
        return res.status(400).json({
            success: false,
            error: error.stderr || "Execution error",
            output: error.stdout || "",
        });
    }
    

    // Compilation and execution code generated by ChatGPT, with some modification
    // let output = "";
    // let warnings = "";
    // try {
    //     if (compileCommand) { // Run compilation if compileCommand exists
    //         try {
    //             const { stdout: compileStdout, stderr: compileStderr } = await exec(compileCommand, { timeout: TIMEOUT });

    //             // Compilation succeeded
    //             output += compileStdout + "\n";
    //             if (compileStderr) { // Warnings present
    //                 warnings = compileStderr;
    //             }
    //         } catch (compileError) {
    //             // If compilation fails, handle it here
    //             return res.status(400).json({
    //                 success: false,
    //                 error: compileError.stderr || "",
    //                 output: compileError.stdout || "",
    //                 warnings
    //             });
    //         }
    //     }

    //     // Run execute command only if compilation succeeded
    //     const { stdout: runStdout, stderr: runStderr } = await exec(runCommand, { timeout: TIMEOUT });
    //     output += runStdout;

    //     return res.status(200).json({ success: true, output, error: runStderr, warnings });
    // } catch (error) {

    //     const isTimeout = error.signal === "SIGTERM";

    //     return res.status(400).json({
    //         success: false,
    //         error: isTimeout ? "Execution timed out (10 second limit)" : error.stderr || "Runtime error occurred.",
    //         output: error.stdout || "",
    //         warnings
    //     });
    // }
}
