import prisma from '../../../utils/prisma-client'
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

// Validation helper functions generated by ChatGPT
// Portions of the file were generated by ChatGPT with modification
function isValidEmail(email) {
  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
  return emailRegex.test(email);
}

const JWT_SECRET = process.env.JWT_SECRET;
const REFRESH_TOKEN_SECRET = process.env.REFRESH_TOKEN_SECRET;
if (!JWT_SECRET || !REFRESH_TOKEN_SECRET) {
  console.error("JWT_SECRET or REFRESH_TOKEN_SECRET is not defined. Exiting...");
  process.exit(1);
}

export default async function handler(req, res) {
  if (req.method === 'POST') {
    const { email=null, password=null } = req.body;

    // Validation to prevent queries with unclean data
    if (email === null || !isValidEmail(email)) {
      return res.status(400).json({ error: 'Invalid Email' });
    }

    try {
      const user = await prisma.user.findUnique({ where: { email } });

      if (!user) {
        return res.status(401).json({ error: 'User not found' });
      }

      if (password === null) {
        return res.status(401).json({ error: 'Password is incorrect' });
      }

      const isPasswordValid = await bcrypt.compare(password, user.password);
      if (!isPasswordValid) {
        return res.status(401).json({ error: 'Password is incorrect' });
      }

      // Generate access token
      const accessToken = jwt.sign({ userId: user.userId }, JWT_SECRET, { expiresIn: '15m' });
      
      // Generate refresh token
      const refreshToken = jwt.sign({ userId: user.userId }, REFRESH_TOKEN_SECRET, { expiresIn: '1h' });

      // Store refresh token in the database
      await prisma.user.update({
        where: { userId: user.userId },
        data: { refreshToken }
      });

      // Send tokens to user
      res.status(200).json({ 
        message: 'Login successful', 
        accessToken, 
        refreshToken
      });
    } catch (error) {
      console.error(error);
      return res.status(500).json({ error: 'Error logging in' });
    }
  } else {
    res.setHeader('Allow', ['POST']);
    return res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}