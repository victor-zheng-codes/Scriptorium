import prisma from '../../../utils/prisma-client'
import { verifyToken } from '../../../utils/auth'
import bcrypt from 'bcryptjs';
import fs from 'fs';

const JWT_SALT = parseInt(process.env.JWT_SALT) || 10; // should be an int

// Validation helper functions generated by ChatGPT
// Portions of the file were generated by ChatGPT with modification
function isValidPassword(password) {
  // Minimum length of 8, 
  // at least one uppercase letter, one lowercase letter, one number, and one special character
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
  return passwordRegex.test(password);
}

function isValidEmail(email) {
  // General email validation
  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
  return emailRegex.test(email);
}

function isValidUsername(username) {
  // Only alphanumeric characters and underscores allowed
  const usernameRegex = /^[a-zA-Z0-9_]{3,}$/; // Minimum length of 3
  return usernameRegex.test(username);
}

function isValidName(name) {
   const nameRegex = /^[a-zA-ZÀ-ÿ\s-]+$/;
   return nameRegex.test(name);
}

function isValidPhoneNumber(phoneNumber) {
  // Matches phone numbers in the format: 123-456-7890
  const phoneRegex = /^\d{3}-\d{3}-\d{4}$/;
  return phoneRegex.test(phoneNumber);
}

export default async function handler(req, res) {
  if (req.method === 'PATCH') {
    const authHeader = req.headers.authorization;

    if (!authHeader) {
      return res.status(401).json({ error: 'Unauthorized' });
    }
  
    // Check if the header is in Bearer token format
    const [scheme, token] = authHeader.split(' ');
    
    if (scheme !== 'Bearer' || !token) {
      return res.status(401).json({ error: 'Unauthorized' });
    }
  
    // Proceed with token verification
    let tokenVerificationResult = verifyToken(token);
    // Check if the token is valid
    if (tokenVerificationResult === null) {
      return res.status(401).json({error: "Unauthorized"})
    }

    try {
      const userId = tokenVerificationResult;

      const {
        email = null,
        username = null,
        password = null,
        firstName = null,
        lastName = null,
        avatar = null,
        phoneNumber = null
      } = req.body; // Include other fields as necessary

      // Initialize the data object
      const data = {};

      // Validate and add fields into data
      if (email !== null && isValidEmail(email)) {
        data.email = email;
      } else if (email !== null) {
        return res.status(400).json({ error: 'Invalid email format.' });
      }
      
      if (username !== null && isValidUsername(username)) {
        data.username = username;
      } else if (username !== null) {
        return res.status(400).json({ error: 'Invalid username format.' });
      }
      
      if (password !== null && isValidPassword(password)) {
        // Hash the password before saving
        const hashedPassword = await bcrypt.hash(password, JWT_SALT);
        data.password = hashedPassword;
      } else if (password !== null) {
        return res.status(400).json({ error: 'Password must be at least 8 characters long and include an uppercase letter, lowercase letter, number, and special character.' });
      }
      
      if (firstName !== null && isValidName(firstName)) {
        data.firstName = firstName;
      } else if (firstName !== null) {
        return res.status(400).json({ error: 'Invalid first name format.' });
      }
      
      if (lastName !== null && isValidName(lastName)) {
        data.lastName = lastName;
      } else if (lastName !== null) {
        return res.status(400).json({ error: 'Invalid last name format.' });
      }
      
      if (avatar !== null) {
          // Construct the full path to the specific avatar file
          const avatarPath = `./public/avatars/${avatar}`;
      
          // Check if the file exists and is a .png
          if (fs.existsSync(avatarPath) && avatar.endsWith('.png')) {
            data.avatar = avatar; // Store the avatar file name
          } else {
            return res.status(400).json({ error: 'Avatar does not exist.' });
          }
      }
      
      if (phoneNumber !== null && isValidPhoneNumber(phoneNumber)) {
        data.phoneNumber = phoneNumber;
      } else if (phoneNumber !== null) {
        return res.status(400).json({ error: 'Invalid phone number format. Expected format: XXX-XXX-XXXX.' });
      }

      const updatedUser = await prisma.user.update({
        where: { userId },
        data
      });

      const { password: _, refreshToken: _2, ...userResponse } = updatedUser;

      res.status(200).json({ message: 'Profile updated', user: userResponse });
    } catch (error) {
      if (error.code === 'P2002') { // Prisma's unique constraint error code
        // checks if the uniqueness error was caused by the email or username 
        if (error.meta.target.includes('email')) {
          return res.status(409).json({ error: 'Email already in use.' });
        }
        if (error.meta.target.includes('username')) {
          return res.status(409).json({ error: 'Username already in use.' });
        }
        if (error.meta.target.includes('phoneNumber')) {
          return res.status(409).json({ error: 'Phone number already in use.' });
        }
      }
      res.status(500).json({ error: 'Error updating profile' });
    }
  } else {
    res.setHeader('Allow', ['PATCH']);
    return res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}