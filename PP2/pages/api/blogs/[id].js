import prisma from '../../../utils/prisma-client'
import { verifyToken } from '../../../utils/auth';

// Validation helper functions generated by ChatGPT
// Portions of the file were generated by ChatGPT with modification
function isValidBlogTitle(title) {
    // Title should be between 5 and 100 characters, allowing alphanumeric and spaces
    const titleRegex = /^[a-zA-Z0-9\s]{5,100}$/;
    return titleRegex.test(title);
}

function isValidBlogDescription(description) {
    // Description should be between 0 and 100 characters, allowing alphanumeric, spaces, and basic punctuation
    const descriptionRegex = /^[a-zA-Z0-9\s.,!?'@%&()-]{20,1000}$/;
    return descriptionRegex.test(description);
}

function isValidBlogContent(content) {
    // Content should be between 20 and 1000 characters, allowing alphanumeric, spaces, and basic punctuation
    const contentRegex = /^[a-zA-Z0-9\s.,!?'@%&()-]{20,1000}$/;
    return contentRegex.test(content);
}

function isValidTag(tag) {
    // Tags should be alphanumeric, no spaces, and between 1 and 20 characters
    const tagRegex = /^[a-zA-Z0-9]{1,20}$/;
    return tagRegex.test(tag);
}

function areValidTags(tags) {
    // Validate an array of tags, return false if any tag is invalid
    if (!Array.isArray(tags)) {
        return false;
    }
    return tags.every(isValidTag);
}

function isValidInteger(value) {
    // Convert value to number and check if it's a valid integer
    const parsed = Number(value);
    return Number.isInteger(parsed) && String(parsed) === String(value).trim();
}

function areValidIntegers(integers) {
    // Validate an array of tags, return false if any tag is invalid
    if (!Array.isArray(integers)) {
        return false;
    }
    return integers.every(isValidInteger);
}
  
export default async function handler(req, res) {
    if (req.method === 'DELETE') {
        // Deleting a post requires authentication
        const authHeader = req.headers.authorization;

        // Validate that the user is authenticated
        if (!authHeader) {
            return res.status(401).json({ error: 'Unauthorized' });
        }

        // Check if the header is in Bearer token format
        const [scheme, token] = authHeader.split(' ');
        
        if (scheme !== 'Bearer' || !token) {
            return res.status(401).json({ error: 'Unauthorized' });
        }

        // Proceed with token verification
        let tokenVerificationResult = verifyToken(token);
        // Check if the token is valid
        if (tokenVerificationResult === null) {
            return res.status(401).json({ error: 'Unauthorized' });
        }

        let blogId = req.query.id;
        blogId = Number(blogId)
        if (!blogId || !isValidInteger(blogId)) {
            return res.status(400).json({ error: 'BlogId should be a valid integer.' });
        }

        const userId = tokenVerificationResult;

        try {
            // Fetch the blog by blogId
            const blog = await prisma.blog.findUnique({
                where: { blogId },
                select: { authorId: true } // We only need the authorId
            });

            // Check if the blog exists
            if (!blog) {
                return res.status(404).json({ error: 'Blog not found' });
            }

            // Verify that the authenticated user is the author of the blog
            if (blog.authorId !== userId) {
                return res.status(403).json({ error: 'Forbidden: You are not the author of this blog' });
            }

            // Delete the blog since the user is the author
            const updatedBlog = await prisma.blog.update({
                where: { blogId },
                data: { isDeleted: true }
            });

            return res.status(200).json({ message: 'Blog deleted successfully', updatedBlog: updatedBlog });

        } catch (error) {
            console.log(error)
            return res.status(500).json({ error: 'An error occurred while deleting the blog' });
        }

    } else if (req.method === 'PATCH') {
        // Editting a post requires authentication
        const authHeader = req.headers.authorization;

        // Validate that the user is authenticated
        if (!authHeader) {
            return res.status(401).json({ error: 'Unauthorized' });
        }

        // Check if the header is in Bearer token format
        const [scheme, token] = authHeader.split(' ');
        
        if (scheme !== 'Bearer' || !token) {
            return res.status(401).json({ error: 'Unauthorized' });
        }

        // Proceed with token verification
        let tokenVerificationResult = verifyToken(token);
        // Check if the token is valid
        if (tokenVerificationResult === null) {
            return res.status(401).json({ error: 'Unauthorized' });
        }
        let {
            title = null,
            description = null,
            content = null,
            tags = null, // tags represents the new lists of tags that the blog will have. its old list will be deleted
            templateIds = null // templateIds represents the new lists of templates that the blog will link to. its old list will be deleted
        } = req.body; // Include other fields as necessary
    
        const userId = tokenVerificationResult;

        // Initialize the data object
        const data = {};

        let blogId = req.query.id;
        blogId = Number(blogId)
        // First validate that the blog exists and that the user is the author of its
        if (!blogId || !isValidInteger(blogId)) {
            return res.status(400).json({ error: 'BlogId should be a valid integer.' });
        }

        // Check that blog exists and is authored by the user
        const blog = await prisma.blog.findUnique({ where: { blogId }, select: { authorId: true } });
        if (!blog) {
            return res.status(404).json({ error: `Blog ${blogId} not found.` });
        }
        if (blog.authorId !== userId) {
            return res.status(403).json({ error: 'Forbidden: You are not the author of this blog' });
        }

        // Validate and add fields into data
        if (title !== null && isValidBlogTitle(title)) {
            data.title = title;
        } else if (title !== null) {
            return res.status(400).json({ error: 'Title must be between 5 and 100 characters, with only alphanumeric and spaces' });
        }
        
        if (description !== null && isValidBlogDescription(description)) {
            data.description = description;
        } else if (description !== null) {
            return res.status(400).json({ error: 'Description should be between 0 and 100 characters, with only alphanumeric, spaces, and basic punctuation' });
        }

        if (content !== null && isValidBlogContent(content)) {
            data.content = content;
        } else if (content !== null) {
            return res.status(400).json({ error: 'Content should be between 20 and 1000 characters, with only alphanumeric, spaces, and basic punctuation' });
        }
        
        if (tags !== null && !areValidTags(tags)) {
            return res.status(400).json({ error: 'Tags should be alphanumeric, no spaces, and between 1 and 20 characters' });
        }
        
        if (templateIds !== null && !areValidIntegers(templateIds)) {
            return res.status(400).json({ error: 'TemplateIds should be integers.' });
        }
        templateIds = templateIds.map(templateId => Number(templateId));

        try {
            // Remove existing associations to templates and tags
            // If new tags are provided, associate them
            if (tags !== null) {
                // Remove all associated tags from BlogTags table first
                await prisma.blogTags.deleteMany({
                    where: { blogId }
                });

                const existingTags = await prisma.tag.findMany({
                    where: {
                        tagName: { in: tags }
                    },
                    select: { tagName: true }
                });
        
                const existingTagNames = existingTags.map(tag => tag.tagName);
        
                const nonExistentTags = tags.filter(tag => !existingTagNames.includes(tag));

                // Create new tags in the database
                const newTagRecords = await Promise.all(nonExistentTags.map(tagName => 
                    prisma.tag.create({ data: { tagName } })
                ));

                // Fetch the tag IDs corresponding to the unique tag names
                const tagRecords = await prisma.tag.findMany({
                    where: {
                        tagName: { in: tags } // Filter by names in the uniqueTagNames array
                    },
                    select: {
                        tagId: true // Select only the id of each tag
                    }
                });

                // Extract the tag IDs into a simple array
                const tagIds = tagRecords.map(tag => tag.tagId); // Make sure to use tag.tagId

                const tagConnections = tagIds.map(tagId => ({
                    tagId: tagId,
                    blogId: blogId
                }));

                await prisma.blogTags.createMany({ data: tagConnections });
            }

            try{
                if (templateIds !== null) {
                    // Remove all associated templates from BlogTemplates table first
                    await prisma.blogTemplate.deleteMany({
                        where: { blogId }
                    });

                    const templateConnections = templateIds.map(templateId => ({
                        templateId: templateId,
                        blogId: blogId
                    }));
                    await prisma.blogTemplate.createMany({ data: templateConnections });
                }
            }
            catch (error) {
                return res.status(400).json({ error: 'Templates provided are invalid' });
            }

            // Update blog with valid fields (title, description, etc.)
            const updatedBlog = await prisma.blog.update({
                where: { blogId },
                data: data
            });

            const returnedBlog = await prisma.blog.findUnique({
                where: { blogId },
                include: {
                    BlogTags: {
                        select: {
                            tag: {
                                select: {
                                    tagName: true // Only include tagName from the Tag model
                                }
                            }
                        }
                    },
                    BlogTemplate: {
                        select: {
                            template: {
                                select: {
                                    title: true 
                                }
                            }
                        }
                    }
                }
            });

            return res.status(200).json({ message: 'Blog updated successfully', updatedBlog: returnedBlog });
        } catch (error) {
            console.error(error);
            return res.status(500).json({ error: 'An error occurred while updating the blog' });
        }

    } else if (req.method === 'GET') {
        // Returns all information about the blog and immediate comments to the blog. 
    // Does not include replies to comments/replies.
    // Seeing a post does not need authentication
    // Retrieve blogId from the query parameters
    let blogId = req.query.id;
    blogId = Number(blogId)

    // Validate blogId
    if (!isValidInteger(blogId)) {
        return res.status(400).json({ error: 'BlogId should be an integer.' });
    }

    try {
        // This query was generated largely by ChatGPT
        // Fetch the blog details along with comments to the blog
        const blogDetails = await prisma.blog.findUnique({
            where: { blogId, isDeleted: false },
            include: {
                Comment: {
                    select: {
                        commentId: true,
                        content: true,
                        upvotes: true,
                        downvotes: true,
                        isAppropriate: true,
                        user: { // Include the user relation to access the username
                            select: {
                                username: true // Select the username field from the User model
                            }
                        },
                        CommentReplyChild: { // Fetch the child comments
                            include: {
                                reply: {
                                    select: {
                                        commentId: true,
                                        content: true,
                                        upvotes: true,
                                        downvotes: true,
                                        isAppropriate: true,
                                        user: {
                                            select: { username: true }
                                        }
                                    }
                                }
                            }
                        },
                        CommentReplyParent: { // Fetch the parent comment by finding where current comment is a reply
                            include: {
                                comment: {
                                    select: {
                                        commentId: true,
                                        content: true,
                                        upvotes: true,
                                        downvotes: true,
                                        isAppropriate: true,
                                        user: {
                                            select: { username: true }
                                        }
                                    }
                                }
                            }
                        },
                        UserCommentRating: {
                            select: {
                                userId: true,
                                rating: true,
                            }
                        },
                        CommentReport: {
                            select: { explanation: true }
                        }
                    },
                    orderBy: [ // Order by upvotes first and then downvotes
                        { upvotes: 'desc' },
                        { downvotes: 'desc' },
                    ],
                }, 
                // Include the Blog's tags and templates when returning it
                BlogTags: {
                    include: {
                        tag: true, // Include tag info
                    },
                },
                BlogTemplate: {
                    include: {
                        template: true, // Include template info
                    },
                },
                BlogRating: {
                    select: {
                        userId: true,
                        rating: true,
                    }
                },
                BlogReport: {
                    select: { explanation: true }
                },
            }
        });

        // Check if the blog exists
        if (!blogDetails) {
            return res.status(404).json({ error: 'Blog not found' });
        }

        return res.status(200).json({
            message: "Successfully retrieved blog",
            blogDetails: blogDetails
        });

    } catch (error) {
        console.error(error);
        return res.status(500).json({ error: 'An error occurred while retrieving the blog' });
    }
    } else {
        res.setHeader('Allow', ['GET', 'DELETE', 'PATCH']);
        return res.status(405).end(`Method ${req.method} Not Allowed`);
    }
}
