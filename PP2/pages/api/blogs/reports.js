import { authenticateUser } from '../../../utils/auth'
import prisma from '../../../utils/prisma-client'
import { isValidId } from '../../../utils/validation';

export default async function handler(req, res) {
    // Authenticate user
    let userId = authenticateUser(req);
    if (!userId) {
        return res.status(401).json({ error: "Unauthorized" });
    }
    
    // Check if method is allowed
    if (req.method !== "GET" && req.method !== "PATCH") {
        res.setHeader('Allow', ['GET', 'PATCH']);
        return res.status(405).json({ error: `Method ${req.method} not allowed` });
    }

    // Verify that user has admin privileges
    const user = await prisma.user.findUnique({ 
        where: { userId }, 
        select: { isAdmin: true },
    });
    if (!user || user.isAdmin !== true) {
        return res.status(403).json({ error: "Forbidden" });
    }

    if (req.method === "GET") {
        try {
            // Query generated by ChatGPT, with some modification
            const sortedBlogs = await prisma.blog.findMany({
                include: {
                    BlogReport: true,
                },
                orderBy: {
                    BlogReport: {
                        _count: 'desc', // Sort by number of reports in descending order
                    },
                },
            });
            const sortedComments = await prisma.comment.findMany({
                include: {
                    CommentReport: true,
                },
                orderBy: {
                    CommentReport: {
                        _count: 'desc', // Sort by number of reports in descending order
                    },
                },
            });
            return res.status(200).json({ sortedBlogs, sortedComments });
        } catch (error) {
            console.log(error);
            return res.status(500).json({ error: "Error fetching from database" });
        }
    } else { // PATCH request
        const { type, isAppropriate } = req.body;
        let { id } = req.body;
        if (type !== "blog" && type !== "comment") {
            return res.status(400).json({ error: "type must be 'comment' or 'blog'"});
        }
        if (!isValidId(id)) {
            return res.status(400).json({ error: "Invalid blog/comment ID"});
        }
        id = Number(id);
        if (!typeof isAppropriate === "boolean") {
            return res.status(400).json({ error: "isAppropriate must be a boolean value"});
        }
        if (type === "blog") {
            try {
                const blog = await prisma.blog.findUnique({
                    where: { blogId: id },
                });
                if (!blog) { // Blog does not exist
                    return res.status(404).json({ error: `Blog ${id} not found` });
                }
                const updatedBlog = await prisma.blog.update({
                    where: { blogId: id },
                    data: {
                        isAppropriate
                    }
                });
                return res.status(200).json({ updatedBlog });
            } catch (error) {
                console.log(error);
                return res.status(500).json({ error: "Error flagging blog as appropriate/inappropriate" });
            }
            
        } else { // type === "comment"
            try {
                const comment = await prisma.comment.findUnique({
                    where: { commentId: id },
                });
                if (!comment) { // Comment does not exist
                    return res.status(404).json({ error: `Comment ${id} not found` });
                }
                const updatedComment = await prisma.comment.update({
                    where: { commentId: id },
                    data: {
                        isAppropriate
                    }
                });
                return res.status(200).json({ updatedComment });
            } catch (error) {
                console.log(error);
                return res.status(500).json({ error: "Error flagging comment as appropriate/inappropriate" });
            }
        }
    }
    
    


}
